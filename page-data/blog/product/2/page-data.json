{"componentChunkName":"component---src-template-blog-categories-template-js","path":"/blog/product/2/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"authors":"Sabrina Lupșan","categories":["CSPM","Product"],"title":"Providing Visibility Over Cloud Access – Okta Integration in Cyscale","seoTitle":"Providing Visibility Over Cloud Access – Okta Integration in Cyscale","description":"Okta is an identity and access management (IAM) service built for the cloud that connects persons with applications through SSO, AD, LDAP MFA, B2B Integration, Mobile Identity Management, User Management etc. Controls in Cyscale check your Okta configurations for the following: if there are at least two Okta admins configured, if application assignments are configured through groups, if MFA is configured and it has strong factors, if there are no weak password policies.","seoDescription":"Okta is an identity and access management (IAM) service built for the cloud that connects persons with applications through SSO, AD, LDAP MFA, B2B Integration, Mobile Identity Management, User Management etc. It is important to integrate an identity provider with a CSPM to monitor security posture in one single place and see all of your IAM users in context. Some controls in Cyscale check if there are at least two Okta admins configured, if application assignments are configured through groups, if MFA is configured and it has strong factors, if there are no weak password policies.","date":"2022-05-27T06:52:44.138Z","featuredpost":true,"permalink":"provide-visibility-in-cloud-okta-integration","featuredimage":{"publicURL":"/static/6b6fe9069a054980003eabcbf1486401/okta-integration-in-cyscale.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/6b6fe9069a054980003eabcbf1486401/888e2/okta-integration-in-cyscale.webp","srcSet":"/static/6b6fe9069a054980003eabcbf1486401/913d0/okta-integration-in-cyscale.webp 205w,\n/static/6b6fe9069a054980003eabcbf1486401/91660/okta-integration-in-cyscale.webp 410w,\n/static/6b6fe9069a054980003eabcbf1486401/888e2/okta-integration-in-cyscale.webp 820w,\n/static/6b6fe9069a054980003eabcbf1486401/6e9bc/okta-integration-in-cyscale.webp 1640w","sizes":"(min-width: 820px) 820px, 100vw"},"sources":[]},"width":820,"height":460}}}},"rawMarkdownBody":"<!--StartFragment-->\n\n### What is Okta? \n\nOkta is an [identity and access management (IAM) service](https://cyscale.com/blog/iam-services-in-aws-azure-gcp/) built for the cloud.  \n\nIt can connect a person with an application securely through its features, such as:  \n\n* Single Sign-On (SSO),  \n* Active Directory (AD) and LDAP Integration,  \n* Multi-Factor Authentication (MFA),  \n* User Management,  \n* B2B Integration for 3rd party access,  \n* Mobile Identity Management, and others.  \n\n### Why integrate with Okta? \n\nThere are some benefits in integrating your CSPM solution with an identity provider. \n\n[A CSPM tool](https://cyscale.com/products/cloud-security-posture-management/) is a cloud security product that: \n\n* offers visibility and discovery for your cloud assets, \n* detects misconfigurations and vulnerabilities, \n* sends targeted alerts, \n* helps you become compliant with international standards, and others. \n\nHowever, if you are using an external provider for user management, like Okta, unless the CSPM has an integration with that identity service, it is not possible for the CSPM to fully accomplish the actions mentioned above. \n\nMoreover, understanding and following [Okta Security Best Practices](https://cyscale.com/blog/iam-okta-security-best-practices/) can significantly enhance your cloud's safety. If you have users in Okta and IAM users in the cloud, you will have to assess their configurations in two different systems, resulting in more work and more room for mistakes. \n\nChecking for common configurations, for example, whether MFA is enabled for all users, can result in steps that need to be completed in two different places. \n\nHowever, when using Cyscale, all you need to do is to perform the onboarding once for both the cloud account and the Okta account.  \n\nYou will be able to monitor security posture for access management in one single place. \n\nThis will reduce the risk of mistakes and make your work more efficient. \n\n### Okta controls – what are they, and how can they help you?\n\nOnce you have integrated your [Okta](https://www.okta.com/) account in Cyscale, a broad range of controls automatically check your configurations and alert you if there are any findings. \n\nLet’s look at some of these controls and what they do: \n\n#### 1. Ensure at least two Okta admins are configured.  \n\nThis control is based on the Principle of Separation of Duties; it checks that there is more than one user with administrative privileges in order to eliminate a single point of failure.  \n\n#### 2. Ensure application assignments are configured through groups \n\nAccess to applications configured with Okta can be assigned directly or through groups. It is recommended that access is assigned through groups because it ensures that: \n\n* no users are mistakenly given access to applications, and  \n* managing multiple users is more efficient. \n\n#### 3. Ensure all users have MFA configured.  \n\n[Multi-Factor Authentication](https://cyscale.com/blog/iam-best-practices-from-aws-azure-gcp/#MFA) is an essential security feature and should not be overlooked when implementing authentication. \n\n#### 4. Ensure MFA is configured with strong factors.  \n\nModerate to strong MFA factors include: \n\n* SMS/Voice/Email \n* Push notifications, \n* WebAuthn, \n* YubiKey OTP. \n\nWeak factors, which are not recommended for MFA implementation, are: \n\n* Passwords \n* Security questions \n\n#### 5. Ensure there are no weak password policies.  \n\nApplying strict policies on passwords by establishing rules that cover all corner cases, such as: \n\n* the minimum password length, \n* the type of characters allowed, \n* the usage of both upper-case and lower-case characters, \n\nis an essential configuration. \n\n### More context with Okta \n\nLet’s look at the following **scenario**: an Okta administrator provisions an [AWS](https://cyscale.com/use-cases/aws-cloud-security/) SSO user with administrator privileges.  \n\nThe administrator from Okta does not have MFA activated, or they may have a weak password if the Okta password policy is not strong enough.  \n\nCyscale provides a broader context for access management provisioning, emphasizing risks.  \n\nThe scenario described above can easily go unacknowledged if a CSPM does not have integration with Okta. \n\n### The identity page – a unified view to see everything in one place \n\nCyscale offers a powerful Identity Dashboard where you can see in one combined view all of the identities from your organization and the level of access they have in multiple systems. \n\nYou can check out a preview of the Identity Dashboard in the image below: \n\n![The identity page in Cyscale](/img/1_blurred.webp#shadow \"The identity page in Cyscale\")\n\nAfter expanding any of the identity rows from the illustration, we can now see the accounts an entity has access to, along with their level of privilege and other important information that you should not miss. \n\nBy integrating with an identity provider, Cyscale offers more context and a better understanding of configurations and risks. \n\nFor example, in the view below, it is easy to take note of identities in your organization that present the most risk. \n\n![The identity page in Cyscale](/img/2_blurred.webp#shadow \"The identity page in Cyscale\")\n\nThe Okta integration is very well rounded for AWS, and more support will be available soon for other providers as well.  \n\n### What is next? \n\nWe know how important visibility is in the cloud. Having all users in one place and being able to visualize access in a unified view can significantly improve discovery and visibility. After Okta, there are more identity providers to come in [Cyscale](https://cyscale.com/), for example: \n\n* Azure AD, \n* JumpCloud, \n* G-suite, and others. \n\n<!--EndFragment-->"}},{"node":{"frontmatter":{"authors":"Andrei Ștefănie","categories":["Product"],"title":"Integrating NATS Into the Cyscale Platform","seoTitle":"Integrating NATS Into the Cyscale Platform","description":"Some concepts and techniques we leveraged to switch to a cloud-native message broker.","seoDescription":"Discover how Cyscale has enhanced cloud security integration by utilizing NATS on Kubernetes for efficient, scalable message-based communication. Read about the journey, benefits, and technical implementation on our blog.","date":"2021-12-22T10:11:16.968Z","featuredpost":true,"permalink":"integrating-nats-into-the-cyscale-platform","featuredimage":{"publicURL":"/static/cb4216e63701672e106156941ccdecaf/nats-horizontal-color.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/cb4216e63701672e106156941ccdecaf/02dc4/nats-horizontal-color.webp","srcSet":"/static/cb4216e63701672e106156941ccdecaf/913d0/nats-horizontal-color.webp 205w,\n/static/cb4216e63701672e106156941ccdecaf/85995/nats-horizontal-color.webp 410w,\n/static/cb4216e63701672e106156941ccdecaf/02dc4/nats-horizontal-color.webp 820w,\n/static/cb4216e63701672e106156941ccdecaf/62a3a/nats-horizontal-color.webp 1640w","sizes":"(min-width: 820px) 820px, 100vw"},"sources":[]},"width":820,"height":461}}}},"rawMarkdownBody":"\n<!--StartFragment-->\n\n## Backstory\n\nCyscale helps you secure your cloud infrastructure. To achieve this, the platform must be able to read (sync) the cloud resources, perform assessments against a set of controls (security and architecture guidelines and best practices), send notifications, generate reports, perform scheduled tasks, and so on. Given the highly distributed and segregated nature of the platform, we chose a microservices architecture on top of Kubernetes. Also, by design, these processes are mostly asynchronous, happening in the background as a result of a certain event or trigger.\n\nBesides direct HTTP communication (REST mostly for the account/user management and GraphQL for everything cloud-related), we make heavy use of message-based communication.\n\nUp until recently, Redis served as our backbone for sending messages. We used Redis Lists to simulate queues (e.g., for sending emails) and Redis Pub/Sub for, well, implementing the publish-subscribe pattern (e.g., for triggering the synchronization of the cloud resources). We knew since the beginning that Redis will not serve as the messaging middleware forever, but we started with it since it was already there for caching and tasks (through [Go Celery](https://github.com/gocelery/gocelery)).\n\nDue to a mix of accumulated technical debt and a desire for simplicity, we decided to invest in integrating a purpose-built technology for handling messages. After a good amount of research covering topics such as operational simplicity, community, and documentation, we decided to go with [NATS](https://nats.io/). As a side note, we continue to love Redis and there are plenty of well-established companies using it as their messaging middleware with great success.\n\nThe rest of the article will cover the main steps we took to integrate NATS into our platform such as understanding the NATS ecosystem, deploying the relevant tools on our Kubernetes cluster using Helm - this will form the main part since this is where we faced the most challenges, and, of course, sending and consuming messages.\n\n<!--EndFragment-->\n\n<!--StartFragment-->\n\n**The NATS Ecosystem**\n\n![The NATS ecosystem encompassing the core NATS server, JetStream, the NATS clients and CLI, and the NATS resources for Kubernetes](/img/cyscale-nats.webp 'The NATS ecosystem')\n\n### Core NATS\n\nAt its core, **the NATS server** is a **publish/subscribe** message broker. It offers **at most once delivery** and works based on **subjects**. These can have a hierarchical structure such as `sync.aws` and `sync.gcp`. Services concerned with messages related to syncing operations for AWS will only subscribe to `sync.aws` while other services might listen for all sync-related messages on `sync.*` (which covers both subjects) or even `sync.>` (which will also cover `sync.aws.ec2` - a separate subject).\n\nAnother feature that provides us with great value is called **queue groups**. This helps us horizontally scale our consumers while making sure that only one instance of a service receives a certain message. If you have experience with Kafka, it resembles consumer groups. What’s nice about queue groups is that they are automatically created when consumers subscribe to a subject and provide the queue group parameter (a simple string that, just like subjects, can have a hierarchical structure). For example, we use the name of the service (e.g. notifier) as the queue group.\n\nWhile the core functionality is great and simple, plain old pub/sub with at most once delivery will not cover all use cases. Subscribers might be under heavy load or even down, there might be a network partition or we might even want to keep messages and follow an approach based on event sourcing (you can find more examples in the [NATS docs](https://docs.nats.io/using-nats/developer/develop_jetstream)). In other words, as soon as we need **temporal decoupling** between publishers and subscribers, we need **persistence**, which for NATS is provided by JetStream.\n\n### JetStream\n\nJetStream adds the concept of **streams** on top of the core NATS subjects. Basically, if you want your messages to be persisted, you can enable JetStream on the NATS server and create a stream that will actually store the messages sent to a subject (or multiple subjects - this is mostly to optimize resource utilization; for example, we have one stream called sync that stores all messages sent to any sync subject - i.e. sync.>).\n\nIf your system takes full advantage of JetStream, at most once delivery transforms into **at least once** and even **exactly once** by leveraging [message deduplication](https://docs.nats.io/using-nats/developer/develop_jetstream/model_deep_dive#message-deduplication) (NATS will discard a message if another message with the same publisher-provided ID exists in the stream over a window of a certain time - 2 minutes by default).\n\nOne confusion we had at the beginning was whether we actually had to do anything to take advantage of JetStream besides enabling it. Again, bringing the simplicity up front, publishers will not require any modification unless you are looking for exactly-once delivery (you will have to add the message ID). They still send messages on a certain subject and, behind the scenes, JetStream will persist them in the configured stream.\n\nOn the other hand, **you do have to create the actual streams** (we will talk about this below) and **adjust the subscribers to use the JetStream API** (part of the client NATS library). Note that you can still use the core NATS API, but your subscribers will not receive messages sent before they started listening (even though they are stored in the stream). The reason behind this is that JetStream actually creates consumers that handle the delivery of messages for each subscriber. You will have to manually create the consumer when using the CLI, but the client libraries will handle this automatically when subscribing to a subject through the JetStream API.\n\nHaving the messages persisted also enables us to take different approaches based on what we want to achieve. We might still follow a pub/sub approach for certain subscribers (these are known as **push consumers**) (e.g. we use this approach for generating user-requested reports) or we might want to have more control over how messages are retrieved in which case we will use a **pull consumer**. This enables us to batch messages (e.g. we do this for sending notifications). Here is how we handle the messages in our notifier service:\n\n```typescript\nexport type MessageHandler = (data: NotificationDto[]) => Promise<void>;\n\nexport const handleNotificationMessages = async (handler: MessageHandler) => {\n    try {\n        const nc = await getNatsClient();\n\n        if (!process.env.NOTIFICATIONS_SUBJECT) {\n            throw Error('NOTIFICATIONS_SUBJECT not set');\n        }\n\n        const jc = JSONCodec<NotificationDto>();\n\n        const psub = await nc.jetstream().pullSubscribe(process.env.NOTIFICATIONS_SUBJECT, {\n            queue: 'notifier',\n            config: { durable_name: 'notifier' }\n        });\n\n        const done = (async () => {\n            let notifications: NotificationDto[] = [];\n            for await (const m of psub) {\n                try {\n                    notifications.push(jc.decode(m.data));\n                    m.ack(); // Wait to gather all messages from the current batch\n                    if (m.info.pending === 0) {\n                        await handler(notifications);\n                        logger.info(`Processing ${notifications.length} messages`);\n                        notifications = [];\n                    }\n                } catch (error) {\n                    logger.error(error);\n                }\n            }\n        })();\n\n        setInterval(() => {\n            psub.pull({ batch: 30, expires: 1000 });\n        }, 1000 * 30);\n\n        logger.info(`Listening for messages on ${process.env.NOTIFICATIONS_SUBJECT}`);\n\n        await done;\n        await psub.destroy();\n    } catch (e) {\n        logger.error(`Failed to initiate message listening ${e}`);\n    }\n};\n```\n\n(yes, most of our services are actually written in Go, hence the naming of some variables)\n\nAnother dilemma we faced was regarding **stream creation**. Who/what is responsible for creating the streams? One option is using the client libraries which expose a method to **idempotently** create streams. While this can work just fine, we didn’t want our services to bother with the technical details of NATS. Also, streams felt more like being part of the infrastructure than part of the actual services. So we continued our research and found [NACK](https://github.com/nats-io/nack) which we cover below.\n\nAs a side note regarding persistence/streaming with NATS, the precursor of JetStream is called STAN, which is now deprecated. We are mentioning this because there are still plenty of tutorials that focus on STAN, but JetStream is the way forward.\n\n<!--EndFragment-->\n\n<!--StartFragment-->\n\n## NATS on Kubernetes with Helm\n\nBeing part of the CNCF, we can expect NATS to have first-class support for Kubernetes. And it does.\n\nSince the entire Cyscale platform is specified as a Helm chart we just needed to add the [NATS](https://github.com/nats-io/k8s/tree/main/helm/charts/nats) subchart as a dependency and configure the values. You can check the [values file](https://github.com/nats-io/k8s/blob/main/helm/charts/nats/values.yaml) from the chart repo for reference. One small detail that cost us a few hours was how we were specifying the values for NATS. If you look at [the documentation](https://docs.nats.io/running-a-nats-service/introduction/running/nats-kubernetes/helm-charts#jetstream), you will notice the `nats` object. However, since we are deploying NATS as a subchart, we will need an additional parent `nats` object to instruct Helm to pass the values down to the nats subchart. Here are our values for NATS on the dev cluster:\n\n```yaml\nnats:\n  nats:\n    image: nats:alpine\n    resources:\n      requests:\n        cpu: 100m\n        memory: 100Mi\n      limits:\n        cpu: 200m\n        memory: 200Mi\n    jetstream:\n      enabled: true\n      memStorage:\n        enabled: true\n        size: 80Mi\n      fileStorage:\n        enabled: true\n        size: 1Gi\n        storageDirectory: /data/\n        storageClassName: default\n```\n\n(notice the two `nats`)\n\nBesides the actual NATS server (which is a container running in the NATS pod along with the monitoring and config reloader containers), we also have a **NATS Box** pod (comes with the NATS Helm chart) that helps us with testing and administrative tasks - basically its a **preconfigured NATS CLI**. We access it using the command `kubectl exec -it <nats-box-container> -- /bin/sh -l`. The other alternative would have been to install the NATS CLI on our machines and port forward the NATS server from the cluster.\n\n### Creating the Streams with NACK\n\nBesides NATS, we also added the [NACK subchart](https://github.com/nats-io/k8s/tree/main/helm/charts/nack) which requires the NACK **CRDs** (install using `kubectl apply -f <https://raw.githubusercontent.com/nats-io/nack/v0.6.0/deploy/crds.yml>`). That’s because it enables us to treat JetStream streams as Kubernetes resources deployed as part of the rest of the platform.\n\nInstead of having our services handle the stream creation or manually creating them from the NATS box, we specify them declaratively as follows (`templates/nats-streams.yaml`):\n\n```yaml\n# See https://github.com/nats-io/nack/blob/main/deploy/crds.yml for more properties\n{{- range .Values.nack.streams }}\napiVersion: jetstream.nats.io/v1beta2\nkind: Stream\nmetadata:\n  name: {{ .name | quote }}\nspec:\n  name: {{ .name }}\n  subjects: {{ .subjects }}\n  storage: {{ .storage | quote | default \"file\" }}\n  retention: {{ .retention | quote | default \"limits\" }}\n---\n{{- end }}\n```\n\nWe also declare the streams as a list in the values file (notice the `range`).\n\nOnce these are deployed, you can inspect the streams just like any other k8s resource using `kubectl get streams`. One issue we faced was that the streams were not actually created in JetStream (`nats stream ls` from the nats box) even though the k8s resources existed. We simply manually deleted them from the cluster (`kubectl delete streams.jetstream.nats.io --all`) and re-deployed the helm chart.\n\nThere is another alternative we considered - the [jetstream Terraform provider](https://registry.terraform.io/providers/nats-io/jetstream/latest/docs). While we do use Terraform to declare our infrastructure on top of which the Kubernetes cluster is running, we chose NACK because it fit our abstraction layers best and because the terraform provider, running locally or in our pipelines, has to somehow reach the NATS server. In our case, the NATS server is not exposed outside of the cluster (again, port-forwarding is an option).\n\n### Ending Notes\n\nWhile there are more subjects to cover such as [authentication](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro) and [authorization](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/authorization), clustering (and [super-clusters](https://docs.nats.io/running-a-nats-service/configuration/gateways)), and multi-tenancy using [accounts](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/accounts), we hope this article helps you better understand how NATS works and how to deploy it. This is our way of giving back to a growing community and expressing our appreciation for getting to work with such great technologies.\n\n<!--EndFragment-->\n"}},{"node":{"frontmatter":{"authors":"Ovidiu Cical","categories":["Product"],"title":"Introducing the next level of security, by Cyscale","seoTitle":null,"description":"We're on a mission to enhance your business, so get ready to embrace the digital future and secure your apps & data in a multi-cloud world!","seoDescription":null,"date":"2020-07-15T07:05:00.000Z","featuredpost":false,"permalink":"next-level-of-cloud-security","featuredimage":{"publicURL":"/static/14a00fe11dd255df8ac621a5f5e35f40/mockup.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/14a00fe11dd255df8ac621a5f5e35f40/757a5/mockup.webp","srcSet":"/static/14a00fe11dd255df8ac621a5f5e35f40/eb5f1/mockup.webp 205w,\n/static/14a00fe11dd255df8ac621a5f5e35f40/81adf/mockup.webp 410w,\n/static/14a00fe11dd255df8ac621a5f5e35f40/757a5/mockup.webp 820w,\n/static/14a00fe11dd255df8ac621a5f5e35f40/1a51a/mockup.webp 1640w","sizes":"(min-width: 820px) 820px, 100vw"},"sources":[]},"width":820,"height":495}}}},"rawMarkdownBody":"\n### Dear friend, get ready to secure your apps & data in a multi-cloud world.\n\n#### The era of remote work and cloud computing is here, and we're excited to share that you can experience enhanced cloud security right from your Cyscale account. This includes:\n\n-   Multi-tenancy support for a Corporate Account and associated Users.\n-   Single auto-onboarding step for multiple Azure Subscriptions under a Tenant.\n-   [Microsoft Azure Marketplace](https://azuremarketplace.microsoft.com/en-us/marketplace/apps/cyscale.cyscale?tab=overview) listing of the Cyscale Cloud Platform.\n-   Signup & access the Cyscale account using Microsoft, Google, or GitHub social logins.\n-   Notifications to _Slack_, _Teams_, _Datadog,_ and _Email_. Whenever your security policies are violated, you're instantly notified. You can also manually send an alert later.\n-   Simplified onboarding for AWS and Google Cloud using CloudFormation and Terraform.\n-   Use API Keys to speed up integrations with CI/CD and other developer tools.\n"}}]}},"pageContext":{"limit":9,"skip":9,"numPages":2,"currentPage":2,"category":"Product","seoTitle":"Cyscale - Product","seoDescription":"Posts about Cyscale Products","categoriesList":["News","Product","CSPM","CNAPP","Compliance","IAM"]}},"staticQueryHashes":["220583031","4109069157","632500807","981947644"],"slicesMap":{}}